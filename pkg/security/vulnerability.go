package security

import (
	"fmt"
	"os"
	"time"
)

// Vulnerability represents a security vulnerability in a package
type Vulnerability struct {
	ID          string
	Package     string
	Version     string
	Description string
	Severity    string
	Published   time.Time
	References  []string
}

// VulnerabilityScanner defines the interface for vulnerability scanning
type VulnerabilityScanner interface {
	ScanPackage(name string, version string) ([]Vulnerability, error)
}

// GithubAdvisoryScanner implements VulnerabilityScanner using GitHub Advisory DB
type GithubAdvisoryScanner struct {
	client *GitHubAdvisoryClient
}

// NewGithubAdvisoryScanner creates a new GitHub Advisory scanner
func NewGithubAdvisoryScanner(token string) *GithubAdvisoryScanner {
	return &GithubAdvisoryScanner{
		client: NewGitHubAdvisoryClient(token),
	}
}

// ScanPackage checks a package against the GitHub Advisory Database
func (s *GithubAdvisoryScanner) ScanPackage(name string, version string) ([]Vulnerability, error) {
	// For npm packages, the ecosystem is "npm"
	// We could extend this to support other ecosystems too
	return s.client.FindVulnerabilities("npm", name, version)
}

// NVDScanner implements VulnerabilityScanner using NVD feeds
type NVDScanner struct {
	client *NVDClient
}

// NewNVDScanner creates a new NVD scanner
func NewNVDScanner(apiKey string) *NVDScanner {
	return &NVDScanner{
		client: NewNVDClient(apiKey),
	}
}

// ScanPackage checks a package against the NVD database
func (s *NVDScanner) ScanPackage(name string, version string) ([]Vulnerability, error) {
	// For npm packages, the ecosystem is "npm"
	// We could extend this to support other ecosystems too
	return s.client.FindVulnerabilities("npm", name, version)
}

// CombinedScanner implements VulnerabilityScanner using multiple data sources
type CombinedScanner struct {
	scanners []VulnerabilityScanner
}

// NewCombinedScanner creates a new combined scanner with multiple sources
func NewCombinedScanner(scanners ...VulnerabilityScanner) *CombinedScanner {
	return &CombinedScanner{
		scanners: scanners,
	}
}

// ScanPackage checks a package against all configured vulnerability sources
func (s *CombinedScanner) ScanPackage(name string, version string) ([]Vulnerability, error) {
	var allVulnerabilities []Vulnerability
	var errors []error

	// Query each scanner
	for _, scanner := range s.scanners {
		vulns, err := scanner.ScanPackage(name, version)
		if err != nil {
			errors = append(errors, err)
			continue
		}

		allVulnerabilities = append(allVulnerabilities, vulns...)
	}

	// If all scanners failed, return an error
	if len(errors) == len(s.scanners) {
		return nil, fmt.Errorf("all vulnerability scanners failed: %v", errors)
	}

	// Deduplicate vulnerabilities by ID
	uniqueVulns := deduplicateVulnerabilities(allVulnerabilities)

	return uniqueVulns, nil
}

// deduplicateVulnerabilities removes duplicate vulnerabilities based on ID
func deduplicateVulnerabilities(vulns []Vulnerability) []Vulnerability {
	seen := make(map[string]bool)
	unique := []Vulnerability{}

	for _, vuln := range vulns {
		if !seen[vuln.ID] {
			seen[vuln.ID] = true
			unique = append(unique, vuln)
		}
	}

	return unique
}

// NewVulnerabilityScanner creates a new vulnerability scanner
func NewVulnerabilityScanner() VulnerabilityScanner {
	// Try to get GitHub token and NVD API key from environment
	githubToken := os.Getenv("GITHUB_TOKEN")
	nvdApiKey := os.Getenv("NVD_API_KEY")

	// Create scanners
	githubScanner := NewGithubAdvisoryScanner(githubToken)
	nvdScanner := NewNVDScanner(nvdApiKey)

	// Return a combined scanner using both sources
	return NewCombinedScanner(githubScanner, nvdScanner)
}
